# Some particular issues with reset pin used as I/O
All classic AVRs provide the option to configure the reset pin as I/O, making further ISP programming impossible. The modern tinyAVR parts, which have one pin that is either used for UPDI or as a reset pin, also permit this, with the same impact of making further programming impossible. Other modern AVRs currently available (megaAVR 0-series, DA, DB) only have the option for it to be used as an input, and it poses no problem. In future announced devices (DD, EA, DU) there will be an option to use the UPDI programming pin as an I/O pin, however, presenting the same issue, and is discussed below as well. No matter which series of parts, there is always a method by which a part can be reprogrammed, regardless of how the reset pin is configured, these are the "High Voltage" programming methods, involving a +12v pulse on the reset pin as part of the programming process. Programmers which support this are uncommon in Arduino circles, and it's use rare, for a number of reasons, which this page describes.

It is important to be aware that configuring Reset (or UPDI on future parts) only disables external programming. Self-programming is still possible, and this is supported by megaTinyCore (typically with the UPDI pin turned into a reset pin). It is also relatively common on classic tinyAVR parts that use micronucleus, a VUSB (bitbanged USB) bootloader, and the original Digispark and Digispark pro shipped with reset disabled. Luckily, current digispark boards available, which are invariably clones, generally do not ship with this set, though you are free to change that with an ISP programmer; this is generally preferable, since it is easy to "opt in" to useing the reset pin as I/O, but rather difficult to "opt out" of it once its set.

## Properties of the reset-as-IO pin
There are a number of special considerations for this pin - it is fundame3ntally different from other pins.
### The output drivers are WEAK
This is likely a result of the HV tolerance, and it is the case on all parts that let reset be used as an output. On the tinyAVR 1-series, for Vcc = 5v, 0.5mA, and the only spec the datasheety guarantees is that it will be within 1 volt of the power rails. It is thus around 1/30th of the strength of other I/O pins (similar ratio for other parts, and it varies somewhat with operating voltage, see relevant datasheets). Similar numbers are found on classic AVRs. Put another way, it can have up to 2k output impedance, even at 5v.(Remember that on tinyAVR's - this is also the UPDI pin! They say nothing about the max current for reset being different from other pins while avoiding damage. It's not clear if there is a "secret" limit beyond which damage would occur that is lower than other pins or not (with drivers that weak, I should be able to hardwire it to vcc, drive the pin "low" and leave it like that indefinitely, probably pulling a couple of mA, well the maximum per-pin current - I suspect that would not be a good thing to do)

### There is no protection diode on the high side
Obviously - but important to keep in mind.

However, there *is* a threshold voltage not far above 12V where anti-ESD mechanisms kick in, and these can be damaged by continuous or excessive current. Be sure to not exceed 12v, and keep the pulse short, and always use that series resistor. If programming isn't working, disconnect the 12v promptly until the problem can be diagnosed.

### As input, it is highly sensitive to EMI (at least on some parts)
Apparently, when used as I/O, weird, unwanted behavior can occur due to electrical noise on the reset pin when used as I/O, usually manifesting as a reset. An individual working with the t841 reported that touching something connected to the pin, or even bringing their hand near it would reset the device. Granted, the configuration in question was highly suboptimal. Thus, when reset is used as an input, you need to be certain it is not connected to long wires or other things that are good at picking up EMI.

This may or may not be a problem on modern AVRs.

### UPDI pin on future parts
Future AVR parts have been announced while allow the UPDI pin to be used as I/O - which is much like setting reset as I/O on classic parts, and renders further programming impossible without an HV pulse *on the reset pin* which can be used as an input, but never as an output. Because the UPDI pin is not HV-tolerant, it can have normal output drivers. On the future DD and DU series parts, particularly the lower pincount device, this would seem to be very appealing - the 14-pin DD has 3 pins used for power (Vdd, Vddio2, and Gnd), reset, and UPDI - leaving 9 I/O pins. If a crystal is used as the clock, only 7. Thankfully, it appears that the HV programming method here will be much easier - A simple addition to a SerialUPDI programmer could realize it and would permit programming without complication. I look forward to the availability of silicon with this feature - though not nearly as much as I look forward to the rest of the featureset on these upcoming parts.

## Reprogramming issues
Reprogramming parts with the pin used for programming also set as I/O is... awkward, moreso on some parts than others. Though on modern AVRs it can often be done in system - it uses only the one pin (two on future parts), and the programming proceedure differs only in in the brief pulse of 12v applied - on classic AVRs the whole thing seems like they tried their best to make it difficult.

### On classic AVRs
A step-by-step algorithm for enabling this is given in the datasheet and varies between devices, involving manipulation of a large number of pins. Typically, parts that use parallel programming use 18 pins (8 data lines, reset, 7 control lines and 1 status output), though sometimes a couple of pins pull double duty (for example, tinyAVRs with 16 pins), while HV serial porogramming (used on classic ATtiny parts with fewer pins, I think is just the x5, x4, x41, and the '13) - 5 I/0 pins including reset, with some parts requiring some additional pins held low.

Disabling reset (or ISP programming) accidentally is commonly said to "brick" the part. The same term is sometimes also used to referring to misconfiguration of the clock source, but that is far easier to recover from - I prefer to call that "soft brick".

Either way, the timing of the HV pulse is coordinated with the application of power. In-system programming is unlikely to be practical - this is either done with a bare chip, or a development board with nothing connected. Beyond that, while the parallel algortithm is not terribly strange looking, HVSP is weird. In a way it's a like like SPI... if SPI had an extra data line in one direction, and used 11 clocks per byte. The 3 "don't care" bits aren't even on the same clock cycle....

#### Fuse Doctors
I've seen code and circuits for HVSP "fuse doctors" which are generally designed to re-enable normal programming only (writing fuses such that reset is enabled, ISP programming is enabled, and the internal oscillator is used as the clock), these will only work for the relatively few devices that use HVSP.

I have not seen an HV PP fuse doctor design that will "unbrick" parts with more pins. The programming would be simple - the hardware, not so much, with something like 20 wires to connect, each an opportunity to make a mistake. Imagine what this would look like - there's something like an Arduino Nano, and a small circuit to provide the HV pulse... and almost every pin has a dupont jumper dangling from it, and you need to connect each one to to right pin of the target. And dupont line is not exactly known for high reliability, either, with terminals, particularly cheap ones, having limited lifespan before they stop making reliable connections. How would you even mark them, as wire is only available in about 10-12 distinct colors? (the resistor color code colors plus pink are not *too* hard to find, and you can do a transparent one to distinguish 12 by color... maybe use that white-and-pink ribbon cable for the 8 data lines, which are usually but not always in a row on the target board?)...

### On modern tinyAVRs
The HV UPDI programming system in contrast is much simpler. All you do is apply a 12V (absolutely not higher than 13V per datasheet warning, and it's only guaranteed to register if it;'s at least 11.5V) pulse to the UPDI line before programming it normally.

To reprogram a part with UPDI/Reset reconfigured to act I/O, however, there's a probem: If the pin is set as output, and driven low, how do you raise it to 12v? (note that reset HV pulse is almost universally applied through a resistor, a very sensible precaution = you want to make sure that if you do accidentally connect it to the wrong pin, it doesn't destroy the target device by shorting a pin to the 12V rail). An appropriate resistor would also not allow 12v to reach pin, despite the incredibly weak drivers on that pin. As noted., there is no spec for maximum current through the reset pin. For that reason, they decided to disable the output buffer on that pin for a short time after POR, so, like a classic AVR, you apply power and then immediatly give it the 12V pulse. This is often called a "power-cycle HV" (PCHV) reprogramming process. This complicates design of the programmer, which must be able to supply power part at the proper time - no problem for a tinyAVR on a breakout board. But if it is say, mounted on the rear of a PCB with the hundreds of LEDs that it controls, this could be a problem. (500 WS2812's, even turned off, will draw about half an amp) and I can imagine far worse

If the UPDI pin was just replaced with reset (which is not terribly uncommon on parts that don't have the alternate reset option), or if it isn't an output (note that you can read the state of the UPDI pin without setting the pin to be GPIO, as long as it never sees something that looks like a UPDI command), all you need to do is keep it powered on, apply the HV pulse, and then program over UPDI. You then need to power cycle the part to clear the pin function override, assuming the pin is still set for some other function. Many people describe doing this with a dangling wire and an 12V battery (A23, the kind that look like a half-length AA battery, not a car battery... I suppose one would work as long as the car wasn't running at the time) As in, connect battery negative terminal to digital ground, connecting the programer to normally except with the UPDI line disconnected from the programmer, briefly touching it to the positive side of the battery (ignoring whatever precise timing the datasheet says you need) before connecting it to the programmer again and writing to it. *this actually works* This has also meant that there are few offerings for such a part.

This also means that **EMI and static can potentially trigger this** as the datasheet warns, so you should take precautions to avoid unwanted HV override. A diode from reset to Vcc will do the trick here. As an aside, the classical autoreset circuit used in Arduino and many similaer boards has a diode there. There have been claims that an autoreset circuit without that could cause flash corrupotion and break the bootloader on classic AVRs when it released DTR (causing a spike on reset) by putting parts into PP mode briefly with noise on the pins triggering a write that broke things, that theory strikes me as far-fetched. But on the modern tinies, if you're using the UPDI pin as reset, if you want autoreset - *you most certainly do need the diode!*

### On all other modern AVRs
To prevent the above problem (and because reset was never a very good output), on non-tinyAVR modern AVR parts released as of Q3 2021, the reset pin cannot be used as an output. Because the UPDI pin cannot be set to act as an I/O pin, there's no need for HV programming,. All programmming can be done through UPDI and the reset pin is not specified as being HV tolerant.

No announced future Dx or Ex series parts permit use of reset as an output - I think this is only a feature of the tinies. While the DA and DB do not have an option to use the UPDI pin as I/O, according to all future product briefs (DD, DU, and EA) that is planned goinf forward, with the pin acting as PF7. I'd wager the only reason this wasn't supported sooner was scheduling pressure the time between the end of the classic AVR development and the release of these parts. The classic ATmega parts were not particularly competitive anymore, and the megaAVR 0-series is hardly the most inspiring device.

The alert reader will have already noticed that the HV UPDI of tinyAVR, and the HV UPDI of the full sized AVRs is not the same. This was related to me by an individual at Microchip who is involved with these parts, though it can also be deduced from the product brief or io headers: When using HV UPDI so you can reprogram a part with the UPDI pin configured as I/O, the HV pulse gets applied to reset not the UPDI pin. That means that programmers designed for the tinyAVRs won't be able to do it without modification.

On the other hand, designing an appropriate programmer is simple - almost trivial - since you don't need to deal with any 12v spike on a data line (which is connected to the programmer too). The UPDI stays between the power rails like any well-behaved IO line, and only reset ever sees the output of your 12v source (which can be made through a charge pump voltage multiplication scheme using capacitors and either PWM plus a few diodes and a 12v zener to keep it at the target voltage, or an external IC, or one of the ubiquitous low cost boost converters). Switch it with an appropriate pair of MOSFETs, and you're done. Probably under 25 cents if you don't need the external IC, and if you don't have a source of PWM for a voltage multiplier handy, specialized low cost charge pump ICs exist, designed for old flash memory that used 12v for erase before the charge pump was integrated into the flash chip, or to generate +/- 12v for RS232 from a 5v supply. The latter have the advantage of also providing a way to switch it. And there is no need to control power for the processor and everything else on the same power rail.

## Conclusion
**Reset makes a lousy output** - avoid using it as one. If you must, it is recommended to use it as an input only.

**Don't use the reset of a classic AVR pin as an I/O pin unless you really, absolutely have to** and you have exhausted all other alternatives, and there's no other processor that you can use that would meet your requirements (Using an ATmega328p in a TQFP-32 package and short a pin or two? A '328pb lets you use the A6/A7 pins as normal I/O pins, and replaces the pair of power pins added with the TQFP version with 2 more, plus you get more timers - though in this day and age, you should also be thinking about more modern part... Or if you need one more pin on the t841 in that tiny package? Maybe it's time to look at migrating to a modern AVR like the 1616 or 1626, which are also far more capable parts, with 6 more I/O pins, and they come in the same tiny package...). The economics of modern AVRs are very different from classic ones. Going from a 328p/pb to a 1284p will add $5-6 to the price! Ouch! The DA and DB family, though, encompasing the same flash range, ranges from $1.70 for 28-pin DA with 32k of flash up to only $2.90 for the 64-pin DB with 128k of flash rated for operation at 125 degrees C. A similar pattern follows in the modern tinyAVR line as well - they range from around 50 cents for a 202 up to $1.30 for a 3217, and versions with the same flash sizem, temperature rating, and pincount vary only slightly in price (a 1627 costs 8-10 cents more than a 1607) (Digikey, 9/21).

**Exception: digispark clones, where it is a viable and usable option,** albeit not one I would recommend. They are not (usually) programmed via ISP and have a bootloader that was written to support this.

**On modern tinyAVR, avoid using reset/UPDI as I/O** - it's bad at being an output, and there aren't many options for programmers that support it.

**On megaAVR 0-series, AVR DA/DB series reset as input is no problem, and there's no option to make UPDI into I/O** other than that you won't have a reset pin.

**On future AVR DD, EA, and DU parts, reset as input is fine, and making UPDI into I/O won't be a big deal...** once people have started selling programmers. But it is entirely possible that at the time of release, there will not yet be any programmers available that support reprogramming them afterwards.

## Final note
An ATtiny user who had previously worked with other microcontroller families commented on how surprising it was that there were so few tools for HV programming on AVR. Considering how much pain you need to accept for a single input with extra caveats or a very weak output, I would be surprised if there were! The reason people don't use reset as an I/O isn't just because the HV programmers are exotic, though that doesnt help. This state of affairs certainly suits certain customers just fine - one use case where reset is usually disabled is in products containing proprietary code, in order to supplement lockbits and other countermeasures against IP theft and data exfiltration - or unauthorized modification and interferance with intended behavior (think of inkjet cartridges with a chip that will continue to tell the printer that they're empty even when the user has refilled them, just like the sticker next to the ink cartridges warns will void the warranty and summon the undead). This flips the advantaged and drawbacks on their head - whether the pin is useful as I/O matters less, and it may not be used at all, they don't want it reprogrammable in system, and the paucity of programming tools is a feature. If I were a designer doing this, I'd use a QFN package (preprogrammed as is normally done) and connect the pin to the center ground pad, so nobody could cut the trace to do anything to it. If preventing modification, just just code theft was the objective, I'd also tell the mechanical engineers to make it hard to remove the PCB or desolder the chip where it was without destroying the product.

You might be wondering why someone who only was worried about code theft would need to go beyond just setting the lockbits. Partly it's paranoia, but there are companies who specialize in unlocking microcontrollers and getting binary out... the level of sophistication varying by the price. I have heard that in some cases this can be achieved by glitching the clock (if it uses an external one) or power supply in a carefully controlled way can allow this to occur, and if you can throw enough money at it (that is if the code on it is valuable enough), much wilder methods might be used to make the chip malfunction such that it allowed the flash to be read when the chip was locked. During the cold war, there are stories of high profile chips haveing snide remarks in russian etched into the silicon, knowing that the Soviet Union, whose semiconductor technology was far behind the West, was likely to obtain some of the chips in spite of the embargo, dissolve the plastic package and examine it under a micrscope. The fact that on the modern AVRs, the lock bits, rather than being a one bit are a byte or longer and must hold a specific reset value for the chip to not be locked is a clue that this is a concern - one has to imagine that it makes attacks more difficult. Entering the realm of speculation, I bet those bytes, though consecutive in the address space are physically far apart.
