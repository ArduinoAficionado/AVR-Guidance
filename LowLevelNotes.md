#

### What is GPIORn/GPIOn?
It's a register - classic AVR parts have three, modern AVRs have four. Like most registers, they hold 1 byte each - but unlike other registers they don't control anything in particular (GPIO, General Purpose I/O ). They are also located in lower I/O space, so IN, OUT, CBI, SBI, SBIS and SBIC instructions work on them. Thus GPIOn|=1<<x and GPIOn&=~(1<<x) (where x=0-7 and is compile-time known) are atomic, (usually true of only the PORTx/PINx/DDRx registers) and compile to a single instruction, they can be loaded and stored faster, and the state of a bit within them can be tested in one instruction.

Because it is easily referenced, but doesn't do anything, and is almost never used in Arduino code, GPIO0 is used by some versions of Micronucleus (including the ones distributed with ATTinyCore) to save the reset cause in case the application needed it, while still allowing the entry conditions to be honored by the bootloader - even if the application never cleared MCUSR (which Arduino code almost never does - even if it were widely known, very few use cases would benefit from checking it). So it stashes the contents of MCUSR in GPIOR0 and clears MCUSR so that bits set by previous resets don't cause it to enter the bootloader (and delay sketch startup) inappropriately. That it could be written with a single instruction was an added bonus in a bootloader where every byte of flash matters.
