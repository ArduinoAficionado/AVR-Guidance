## UPDI series resistor and jtag2updi
All "modern" AVR's are programmed via UPDI. UPDI programming is often accomplished by loading the "jtag2updi" firmware onto an Arduino Nano or similar cheap, abundant board. These cost a fraction of what the official programmers cost - even accounting for the large discounts that Microchip frequently offers on them. More importantly, they work great with avrdude, the de facto standard software for uploading to AVR devices among hobbyists and Arduino users in general. When building your own UPDI programmer and/or board (as is widely documented), there must be a resistor in series with the UPDI line. There has been some level od confusion regarding the appropraite resistor for this application.* One of the most widely cited values is 4.7k - this is actually inappropriate for any hardware designed to opperate as a programmer.


### Purpose and requirements
**The exact value of this resistor is far from critical**. This "series resistor" on the UPDI line has only one purpose: To protect the chip and the programmer from damage due to excessive current through an I/O pin in the event that the target and programmer somehow end up out of sync and try to drive that line in opposite directions. It also serves to prevent damage in the event that the programmer is running at a higher Vcc than the target (see note below). This is a very weak constraint -The **recommended**  maximum of 20 mA would give a lower limit of just under 270 ohms, assuming there was no voltage drop across the pin drivers (which of course isn't a valid assumption).

Obviously it must also do this without interfering with programming. Like AVR reset pins, the UPDI pin always has the internal pullup. Per datasheet this has a minimum equivilent resistance of 20k ohms. The programmer must be ablke to drive this pin low for the target. With the threshold for a LOW of 0.3 x Vcc, a 4.7k resistor is dangerously close to this boundary condition (assuming worst case strong internal pullup) - 4.7/(20+4.7) = 0.2 x Vcc. This suggests that a lower value would be more appropriate, and farther from these limits.

### Target vs programmer
The next question is whether to put the resistor on the target or the programmer. Placing it on the target has the advantage of allowing a cheap programmer to be readily fabricated from abundant Nano clones. Being able to make a programmer with just dupont jumpers and and a nano means that one can be made without soldering, putting cheap UPDI programming within easy reach of electronics novices: it becomes as easy as Arduino as ISP. However, most official programmers have their own series resistor, typically in the range of hundreds of ohms to 2.2k, though some have none at all, or have them by default by virtue of weaker pin drivers. It is highly desirable for these to be capable of programming a board without issue.

### Conclusion
Because the range of acceptable resistor values is so wide, we can easily choose a value which allows use with a programmer with or without it's own resistor. My current recommendation is that a **470 ohm** resistor. one can be placed on both programmer and targets and as long as one of them has it, the requirement will be met, it won't interfere with most any programming method one might use.

## Resistors and/or diode for pyupdi/SerialUPDI
Pyupdi has existed since the tinyAVRs were first released, and relied on a serial adapter, with it RX line connected to the UPDI pin, and TX to RX (and UPDI) through a 4.7k resistor. During development of SerialUPDI difficulties were occasuionally encountered. The value of the resistor sometimes had to be changed for certain serial adapters, for example, which made it difficult to write up coherent instructions - far better results were achieved by uising a shottky diode, and a lower-value resistor.

### Purpose and requirements
While the TX pin is high (idle) and the target attempts to drive the UPDI pin low, it must be able to do so. This may sound like a trivial requirement. If the target is a tinyAVR.... go take another look at that datasheet. Likethe reset pin on classic AVRs, the pin drivers are WEAK (I suspect this is a consequence of the requirement the pin be HV tolerant). You can't get much morethan 1 mA out of it! And sure enough,

## Notes

### Vcc differences
It is often cautioned that the operating voltage (Vcc) of the target must not be higher than that of the programmer (eg, from the jtag2updi readme "since the UPDI pin is high voltage tolerant, it's ok to have V_prog > V_target, but not the reverse. ". This caution, while well-founded in principle, is in fact not nearly as much of a concern as many suppose, since any appropriate series resistor will also limit the clamp current or "current injection", and that current is driven only with the difference between the two supplies behind it. If the programmer is also a modern AVR,
### megaTinyCore background + history
It is not credible for me to deny that I contributed to this confusion. I was initially confused myself as to the purpose and requirements for this resistor, and for over a year, promoted the use of a 4.7k resistor. This is inappropriately high, as described above. Customers complained about this when I was selling boards with this value of resistor, leading to the change in my recommendations amd assebled boards in Q2 2020.

This whole discussion begs the question: "What is the Microchip recommendation for this?"

I have looked for such a recommendation. I have not found one. Some of their programmers have a resistor, and others don't; my interpretation of this is that Microchip expects that few people will be building their own in-house peogramming solutions (likely true in industry) and those who do will be qualfied to determine an appropriate value (through analysis like what I described here). The sort of non-industrial user who would use SerialUPDI or pyupdi, or jtag2updi is probably not a major concern.   When I started selling my tinyAVR breakout boards, I had somehow gotten the idea that 4.7k was an officially sanctioned  value - my best guess as to where that came from is that I saw it in the documentation for pyudpi, which was (and still is) a very popular tool for programming these parts. Pyupdi is not an official Microchip product - though, being as it was written by a Microchip engineer and its functionality later rolled into pymcuprog by the same individual (pymcuprog *IS* an official tool; it also happens to form the basis for SerialUPDI used by megaTinyCore and DxCore.i) - but regardless, the value of resistor needed for pyupdi-type programming is determined by entirely different constraints than the series resistor for use with a programing tool like jtag2updi.
