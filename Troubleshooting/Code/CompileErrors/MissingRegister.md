## Hardware register not declared
If a variable used in a library, or a piece of code you copied without understanding it, is not declared, and the code works on the part that the library or code block is using was written for, but not on the part you want to use it on, and the name of that "variable" is in ALL CAPS, maybe including a number or two, _, and maybe a . - that so-called variable is probably actually a hardware register. A hardware register is kind of like a variable like variables, they store a value (almost all are 8-bit, ie, a byte in size, though many have some bits that always read 0). You can read values from them, and assign values to them like a variable, but the value has a specific meaning w/regards to the behavior of the hardware. Every piece of code that makes timers time or generate PWM, pins toggle, serial pins do serial, or anything part of the chip do anything useful, either uses hardware registers, or calls things that use them. That's what all of the Arduino functions do. 

Hardware registers follow specific naming conventions (as described above; they are also aggressively abbreviated, `CLOCK_SOURCE` is unlikely to be a register name... but `CLKSRC` probably is), and are supplied by the compiler toolchain (if they're not defined for some part, that means the part doesn't have that register - or it's named something else, which, unfortunately, occured on a few parts). If you see names that look like registers, first double-check that correct board is selected. An outline of how one might debug this is shown below.

### First thing to check - did they tell you it won't work?
Scroll up in the compiler output. Do you see a message about using a library that specifies that it's for one architecture, and it may not work on the one you're using? If so, that's your problem (though not all libraries that specify an architecture are compatible only with that one, usually they are). 

Check the library docs to see if it has a list of supported parts; frequently they also state why other parts aren't supported.  

If these tell you that the library is not supported, then you need to locate a similar library for the part you want, port the library you have, or write one from scratch. This guide is concerned with the case where there is no architecture warning, and you're trying to determine which of the following is true:
* They are written for different architecture, and it just isn't declared (porting this is a big deal - beyond scope of this article)
* They are written for the same architecture, but the differences are small, and it could be adapted with minimal effort - including how to do it. 
* They are written for the same architecture, but your part lacks key peripherals or features that the code requires, and probably needs a total rewrite, if what you want is even possible.

### General pattern
Frequently code involving directly manipulating a register look like `REGNAME|=(1<<BITNAME);` or `REGNAME&=~(1<<BITNAME);` or - for modern AVR parts, `PER0.REGNAME|=PER_BITNAME_bm` or `PER0.REGNAME&=~PER_BITNAME_bm` - Both REGNAME and BITNAME could be undefined (which is a good sign that the part doesn't have the functionality your code or library relies on) - the first of those sets bit BITNAME in REGNAME, and the latter unsets it (if you're confused, look up bitwise operators in your favorite C/C++ resource). To users with prior exposure to them, these are immediately obvious - if you haven't, look for the following patterns:
### Combination of capital letters, numbers - almost always shorter than 8 characters - ex "TCCR1A"
* Register names and bit names for classic AVR devices. 
* If you're working on a tinyAVR or megaAVR 0-series, tinyAVR 1-series, or DA-series, the code or library you're using needs to be rewritten to support the "modern AVR" devices; this is usually possible, but may require someone experienced with the relevant peripherals on both parts (a rare few use cases can be hard to port - but most aren't hard. It's mostly a matter of comfort with how the relevant peripherals work on both parts.  
* If you're working on a classic AVR, yet a register name (something that is being read or written to) is undefined
  * TIFR, TIMSK, TIFRn, TIMSKn, GIFR, GIMSK - these are interrupt flag and mask registers, and the names and layouts of these registers vary a lot between parts. Search for the register in the datasheet for the atmega328p, then go look in the same chapter of the datasheet for the part you're working with and see if you can find the equivilent register (if it doesn't have an equivilent chapter, the device you're working on doesn't have that peripheral). For example, The ATtiny85 puts the interrupt flags from both timer 0 and 1 into a register called TIFR, whereas almost every other classic AVR has a TIFR0 and TIFR1. 
  * `TCCRnA/B/C`, `OCRnA/B/C`, `TCNTn`, `ICRn` - configuration registers for timers - does the part you're working with have timer `n`? Is it the same kind of timer as on the part the code was originally written for?
* On classic AVRs, the idioms described above are ubiquitous 
  * if you see someone writing numeric values to a register, unless it's one of the few where that makes sense (like OCnx for PWM duty cycle), they did the math for `1<<BITNAME` for all the bits they want set or not-set, but wrote the result, instead of leaving what generated it there, so someone reading the code has to study the datasheet to see which bit is which, instead of just what each bit does. Since the compiler will condense them all down to a constant at compiletime, this practice just makes the code harder to read, not more efficient. Don't do that in your code!
* In general, you want to search datasheet of the part the code was written for for that register or bit name, see what peripheral it's associated with, and then see if the part you want to use has the same peripheral. 
### Short combination of capital letters and numbers, a `.` or `_`, then another set of capital letters and numbers
* Register names for tinyAVR or megaAVR 0-series, tinyAVR 1-series, or DA-series (ie, "modern AVRs")
* If using a classic AVR, the code you are trying to use is not supported there: It was written for one or more of the parts listed above. It must be rewritten to support those parts; this may not be possible due to the less sophisticated peripherals on the classic AVRs.
* If not using a classic AVR, check the datasheet to see if the peripheral (the part before the underscore) exists on the part you are using. If not, code must be modified to use hardware that your part has - if possible (it may be that the code requires a peripheral that your part simply doesn't have - for example TCD0 on a 0-series part (those are only in 1-series or DA-series).
#### Combination of capital letters, numbers, and underscores, followed by _bm, _bp, _gc, or _gp
* These are the names of bits on for tinyAVR or megaAVR 0-series, tinyAVR 1-series, or DA-series. 
* _bp is bit position - like the names of registers on classic AVRs.
* _bm is bit mask, that is PER_BITNAME_bm = (1<<PER_BITNAME_bp) - bit masks are far more commonly used than bit positions, and are used the same way as (!<<BITNAME) on classic AVRs. These bitmask defines make the code easier to write and read.
* _gp is group position, the equivilent of bit position where there's a group of bits that does something, like setting the system clock prescaler, or choosing which mode a peripheral is in when there are more than 2 options. It's the position of the lowest bit in the group. 
* _gm is group mask - this has all bits that are part of that group as 1's, and the rest zeros. 
* _gc is the "group code" for a particular setting from a multi-bit field, and _gp is the position of a multi-bit field within a register.
* A very common idiom for groups is `PER0.REGNAME=(PER0.REGNAME&(~PER_GROUP_gm))|PER_REGNAME_OPTION_gc` - this replaces the current setting for that group with the new setting, leaving the rest of it unchanged.
* Inconsistent naming between parts is (so far) much less common on these parts - except relating to `EVSYS`, the event system, where there are different conventions between each family of parts. *The event system is new with the modern AVRs (part of their claim to fame), but a lot of design decisions were involved, and it looks to me like they made some that got in the way of the next family, and had to "fix" them to make each new family's evemt system possible.*
* If using a "modern AVR", which does have the peripheral - is it referring to a feature that doesn't exist on your part? For example, TCB_CLKSEL_EVENT_gc or TCB_CASCADE_bm on tinyAVR 0-series or 1-series or megaAVR 0-series - those parts don't support clocking TCB's off event or cascading two timers (which depends on clocking the second one on event); only the DA-series parts do that.
#### Other architectures use similar conventions - capital letters, numbers, underscores, and sometimes .'s as separator. 
* Other architectures, such as SAM (arduino Due/Zero/etc), the ESP's, and so on, will be much harder - or maybe even impossible - to port, compared to AVRs.
### Next steps
* If you're seeing classic register names, and are trying to build for a "modern" AVR, or vise versa, you're going to need to find a similar library for the part you want, port it yourself, or write one that does what you need. And if you didn't get that warning mentioned at the top, the author didn't accurately list the architectures it was for in his library properties file (if it's immediately obvious where to report it (typically github issue), would suggest reporting that that information is missing and/or wrong and should be added.
* Assuming that's not the case, and particularly if it's one of the registers mentioned as troublemakers for classic AVR, or relates to EVSYS for modern AVR, the fix might be easy. In all cases, you can get an idea of how much hope you have. Go get the datasheets - your need the datasheet from a part where it does compile, and the datasheet for the one you're trying to use where it doesn't. 
* Search the datasheet where it works for the undefined register, or the undefined bit (on modern AVR, just go directly to the chapter for the first part of the register name in question, to register description section at the end of the chapter, and try to find that register manually. 
* You'll likely find matches in the chapter on a specific peripheral. In the other datasheet, see if there's a chapter for the same peripheral (if there isn't, it probably doesn't have the same hardware; you may well be out of luck there). Compare the description of the peripheral at the start of the chapter - if they sound the same, they probably are, or are very similar. If they sound different (for example, Timer1 on most parts is a 16-bit timer with PWM, but on the ATtiny85, it's an 8-bit high speed timer). If it doesn't have the peripheral, or it's closest equivilent is way different, you're probably out of luck. It would need to be rewritten from scratch with the peripherals present on your chip - if it's even possible with that hardware!
#### Both have same peripheral, but not with the same number
  * This is an encouraging sign!
  * For example, you see code that uses TCCR3A, for a Timer3, a 16-bit timer with PWM, your chip doesn't have Timer3, but it's got a Timer1 with the same description? 
  * Compare the names of the registers - if they're the same, and just the numbers are different, it may be as simple as changing the numbers
  * But first check the code/library for use of any of the registers you hope to manipulate. If the code is already duplicated (ie, searched for TCCR1A, and found the same code, only with 1's instead of 3's, that TCCR3A was used in), check further up for a #ifdef checking for a define saying what timer to use - if that's the case, just changing it would might get you what you want! (it may be defined in the header, rather than the c or cpp file) - there may even a comment there saying why they picked it (in the Timer3 vs Timer1 example, maybe there is a comment saying the library was written for the mega2560, and he didn't want to break tone() which uses timer1 - If you don't need anything using timer1, you're home free!). If it's doing something else with them, it likely needs to use both instances, and thay's why they picked the higher numbered one. That's bad news: your chip probably doesn't have enough of those peripherals to do what the library is doing - Probably time to start looking for a different library, or considering the possibility that your chip doesn't have the peripherals for what you need. 
  * Certain peripherals are used by the Arduino core libraries, so you may not be able to take them over without breaking things you want to use: Serial uses USART0, Tone uses Timer1 or a TCB (Type B Timer), as does Servo. Wire uses TWI (or TWI0), SPI uses SPI (or SPI0). Timer0 is used for millis on classic AVR (on modern AVRs, except for megaTinyCore, a TCB (type B timer) is used, on megaTinyCore, due to the paucity of timers they have, you can select which one to use). Each timer has it's own PWM pins (usually 2 on classic AVR, sometimes 3, and rarely 1 - or zero. On a "modern AVR", a TCA has 3 16-bit pins or 6 8-bit ones (and reconfiguring it may also take out the type B timers), a TCB is a very nice 16-bit utility timer - or a really limited 8-pin PWM timer with only one output, and a TCD is a really weird async timer with 2 outputs and lots of weird quirks that make it challenging to work with), each timer taken over will render PWM on certain pins inoperable. When using a timer for generating PWM, the timer determines which pins it can appear on.
  * If it doesn't conflict with anything you need if you were to take over the instance of that peripheral that your part does have, you should be able to just rename the registers and bits in the code to the instance of the timer your part has, maybe change which pins it uses for it (this is usually shown in pinout at top of datasheet), and it should work. Be sure to look for any ISR() or SIGNAL() routines that refer to that peripheral to, those must also be moved to the peripheral you have. Make sure you also change the place where they enable to interrupt to enable the one for the other peripheral (trying to use ISR() for a non-existent vector isn't a compile error, surprisingly - but if an interrupt that doesn't have a handler fires, it crashes the chip.)
#### If both devices have the same peripheral, same number
 * This is a VERY good sign! But then, what's different?
   * Check the registers at the end of the chapter, and see if there's one that has some of the same or similar bit names (This is the case with TIFR, TIFRn, GIFR, and TIMSK, TIMSKn, GIMSK which hold flags marking when timer interrupts (and sometimes other interrupts) have fired (Interrupt Flag Register) and which interrupts are enabled (Interrupt MaSK). If they do the same thing, you can probably just use the same register (be careful to not flip bits associated with other peripherals in the process, though). For bit names, and sometimes register names, sometimes the numbers are dropped on parts with only one of a peripheral). 
  * If you can't find similar bits, you may be up hoping to use a part which lacks some functionality that the library needs. Depending on your comfort level with the code, and reading datasheets, you may be able to figure out how that functionality is used, and whether it matters (If a feature that your part doesn't have is being turned off, no problem, just remove that part. If it's being used, that's more of a problem. This is beyond the scope of this quick guide. 


Anyway - that's a sort of step-by-step guide to how to look at a library that's not compatible for a part you want, and what the "red flags" are that a quick simple fix is not possible due to differences between the parts. I hope at least somone understood and was able to make use of it. 
