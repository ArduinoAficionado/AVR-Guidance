# Glossary of terms
This covers terms which are not already in ubiquitous use within the Arduino and AVR communities in the wider internet. It came out of a need for words or phrases to describe certain concepts which are routinely referenced. In some cases these terms were in use - although not common use - before. In other cases, descriptive words were chosen in the hopes of being self-explanatory (but which may not be). Confusing terminology used in the documentation for cores that I maintain should be covered here - Please report as an issue for this repo if you find words that need a definition in my documentation. 

**Status: Far from complete, but still useful**

## Terms for types of AVRs
Docs I write use two unofficial names to refer to the two broad classes of parts to which this guide applies. This is not the official terminology that Microchip uses. 
* `classic AVR` refers to any AVR part with the old-style peripherals - specifically, each port is controlled by registers named PORTx, PINx, DDRx (where x is the letter representing the port in question). The classic AVRs have very similar peripherals - they basically have a set of peripherals chosen from a list of standard peripherals (though there are a few parts with one or more unique peripherals - for example, the tiny x5 and x61 series both have a "high-speed timer" instead of the usual Timer1, though there are significant differences between the timers on those parts).  
See (classicperipheraltable.md)(this table of Classic AVR peripherals and which parts have them) for a full list (this table has not been created as of 4/14/2020, but it will be)
* `modern AVR` refers to any AVR part with the new-style peripherals - this currently includes the tinyAVR 0-series and 1-series, the megaAVR 0-series, and the AVR-DA series (which appears to be what would have been the megaAVR 1-series, had they not changed the branding). This had previously been referred to as "megaAVR" in many Arduino circles, and that is what the IDE internally calls this architecture - however this terminology is unofficial, and presents confusion, since Microchip refers to all ATmega processors as "megaAVR". We try to avoid using `modern AVR` except where it is onerous to avoid.

The official terminology for these series of parts is as follows:
* `tinyAVR` - All 'ATtiny' devices.
* `tinyAVR 0-series`, `tinyAVR 1-series` and `tinyAVR 2=series` - The ATtiny devices featuring the new peripherals
* `megaAVR` - All 'ATmega' devices
* `megaAVR 0-series` - The ATmega4809, 4808, and smaller-flash versions of these parts, featuring the new peripherals.
* `AVR DA-series`, "AVR DB-series" and so on, featuring the new peripherals plus additional enhanced features. They are named as `AVR___Dx___ where the first blank is the flash size in kb, the x is replaced with a capitol letter denoting the featureset, and the final blank is filled in eith the pincount.
* `AVR Dx-series` - The DA-series, DB-series, DD series as a whole. I consider this official as this is in the Microchip ATPACK name.
* `AVR Ex-weries` - An upcoming product line that will start with the EA-series, which has an advanced ADC that first appeared on the tinyAVR 2-series and which is clearly targeting a somewhat lower end of the market - pincounts range only from 28 to 48. and flash ranges from 8k to 64k. 

## General Terminology
Sorted by approximate frequency of use

* `target` the device being programmed. Generally used when the programming is performed through another device, referred to as the `programmer` - particularly when the programmer is also programmable via the Arduino IDE (such as with Arduino as ISP, or jtag2updi) and probably has pins with the same or similar names as the target.
* `toolchain` refers to the package of compiler tools and libraries required to compile code for a given architecture. In the context of Arduino and AVR parts, this consists of avr-gcc, the device-specs which contain information on specific parts, the linker scripts which tell the linker where to locate the compiled code within the compiled binary, the precompiled .a and .o files for specific parts, and avr-libc, the collection of standard C/C++ libraries that provide basic functionality for the AVR parts and provide very basic wrappers around AVR peripherals. avr-gcc and avr-libc are available as separate packages, while the part specific libraries, including io*.h are supplied by the "atpacks"provided by Microchip. The Arduino compiler toolchain packages contain all three, and precompile a large number of device-specific .o files.
* `core` colloquially refers to the package of files that can be used to add support for new parts to the IDE; that is why almost every hardware package includes "core" in it's name. *Technically*, the `core` specifically refers to the implementation of the Arduino functions on that class of processors, rather than the rest of the package - the board, platform, programmer definitions, for example, though the two are usually tightly coupled. Depending on the specific hardware package (and the demands of the parts it supports), the core may or may not be shared with other hardware packages (for example, (almost?) all classic megaAVR parts can use the same core; similarly megaAVR 0-series and tinyAVR 0/1-series devices could use the same core - though currently they do not, for a variety of reasons).
* `variant` As noted above, hardware packages will often support many parts which can share the same core. The differences betweem parts with different numbers of pins or port-to-pin mappings are often provided by a single file within the "variants" directory inside the hardware package, which typically contains only a single file: pins_arduino.c. This is the file that contains arrays and macros that map Arduino pin numbers to ports, analog pin numbers (`An` naming) to ADC channels, PWM pins to their timer and channel, and so on. Parts that differ only in the amount of RAM (and sometimes presence or absence of peripherals, for example, tinyAVR 1-series vs 0-series) can be supported with the same variant.
* `UART` - Also called a `serial port` - this is what is used by Serial. The name stands for Universal Asynchronous Receiver-Transmitter. See also `USART` below for usage notes. 
* `USART` - As above, but has an additional feature that an XCK pin can be used as a clock, instead of using a pre-arranged baud rate. It is common for `UART` to be used to refer to either type: a `USART` can act as a UART, but a `UART` cannot do synchronous serial, only async. Stands for Universal Synchronous/Asynchronous Receiver-Transmitter. AVR parts generally (all?) have a `USART`, not just a `UART` - however, use of the XCK pin is unheardof in Arduino applications, and quite rare in general - it is a "low cost" feature for the manufacturer to implement - likely basically free if there is support for reconfiguring a `USART` to act as an SPI port, which is ubiquitous on AVR parts.
* `mxxx` where the x's are numbers and sometimes letters. Refers to an `ATmega xxx. Often used by programming tools. 
* `tnxxx` and `txxx`- as above, but for tinyAVR parts. The convention of tnxxx comes from the naming of the io header files that Microchip supplies, ex, the ATtiny3224 might be abbreviated t3224 in informal discussion or where space is at a premium. The header file that contains names for all the registers on that part is named iotn3224.h. 

## AVR Jargon referenced from other documents
* `SFR` - Specoal Function Register. These are defined by the toolchain headers, and are how the on-chip peripherals are referenced. The are given distinctivenames. On Classic AVRs, they always are spelled only with a small number of captial letters and numbers. On modern AVRs, where there might be more than one of a peripheral the peripheral, somtimes followed by as number, then a `.` then a name as describeb above. 
### Examples
* (classic AVR) `ADCSRA` (**A**malog to **D**igital **Co**nverter control and **S**tatus **R**egister A.
* (modern AVR, one instance) `RSTCTRL.SWRR`  - ReSeT ConTROL Software Reset Register. 
* (modern AVR, multiple instances of peripheral) `TCA0.CTRLA` - Timer Counter type A, number 0, ConTRLA. 
* `SP` - Stack Poimter. Presmt om all AVRs with RAM. a 16-byte regoster (SPL amd SPH). Modifting these registers is dangerous businessm and is best left to wizards, am even they shoudl use exrreme caution. Afer writing one of these manually interrupts are disabled for 4 clock cyclea or until the other one is
* (modern AVR) `CCP` - Configuration Control Protection. Particularly importat functionality that could have catastrophic effects if misconfigured. This includes most clock-related things, as well as self proramming of the flash.  Don't uise it directly uinless writing at an extremely bare metal level; use the `__PROTECTED_WRITE(register, value)` or `__PROTECTED_WRITE_SPM()` macro
### Although they are located in the same address space as normal memory, they do not act the same om all cases in terms of reading and writing
* Most act like a normal memory address, bit some bits are masked off and always read as 0. These are shaded gray in the datashet. We are supposed to always write 0 tothem. In a few rare case, tricks are possible by writimg illegal values to SFRs. 
* Many "Status" registers (or bits within them) are read only. It the bit indication that tha analog comparator says one voltage is higher than the other by reading a 1, attepting to write 0 to it will be ignored, for obvoous reasons.,
* So-called "flag" registers work backwards. They are set to 1 by the system, and are cleared by writing 1. This allows for example, the 8 bits of the INTFLAGS registers to be used most easily: to clear it N, you write 1 << N to the register, the other bits are not disturbed, and crucially, there is no read-modifty write process. 
SP and CCP disable interrupts for 4 clocks automatically. Be sure to precacilate the value you're writing to them. 
### SFRs are declared volative and have sideffects
* These registers are usused to cotrol the behavior of the CPU and its peripherals. 
* Writing to them is how you convfigure peripherals. In Arduino land, this is usually covered by a more human readable API functiosn. 
* Reading from them provides information on he state of the chip. For example, `PORTA.PIN` tells you the digital values of the up to 8 pins on PORTA. 
* Sometimes reading from one register will clear a bit in another register (most common in things like serial data transfer protocols - where reading the incoming data will clear the flag that indicates new data. 
* (modern AVRs) Mever use |= ^= or &= when using a SFR wose name ends in SET, CLR or TGL.
### Low and High I/O space
The lowest 64 addreses (0-63 in the data space) are termed I/O registers (the are also SFRs). These are important on modern AVRs, and even more important on classic ones
* The High I/O space is 32-63. It containst things like SREG, SP, CCP, and a few others. On classic AVRs, these are usually packed with other SFTs. On modern AVRs they are not. They can be loaded from or written to in a single clock cycle.
* The powerful Low I/O spacea is 0-32 (note, yes, you can dereference a null poimter, and it's a valid register).  It has the propertioespf the high I/O space... Plus there are special instructions (CBI and SBI) to set and clear a single bit as an atomic operation. This took 2 clocks on a classic AVR, buy only one on modern ones. Likeise, there are SBIC md SBIS insructopms - Skip (next insn) of Bit in I/O is Clear/Set.  These make both writing and testing single bits exrtemely fast, and can be used very easily: `VPORTA.DIR |= 1` will set PA0 as an input. Note that both the bit and value must be known constants at compile tiem!  While classic AVRs frequntly put registers here almiost at random, all modernAVRs have kept it simple. Each VPORT (A-G) has 4 registers: DIR, OUT, IN, and INTFLAGS (the effects of these registersa are mirrored in the PORT registers). That leaves 4 registers, the GPIOR or GPR regesters. They have no special function except that thay are in the low I/O space for user use. 
  * You can only set one bit at a time like this - otherwise, use the `PORTx.___SET/CLR/TGL` registers. 
  * VPORTA.OUT = 1 is slower than VPORTA.OUT |= 1 (it has to first load the value 1 into a working register to write)
  * Writing a 1 VPORTx.IN (but not PORTx.IN) will toggle that bit. Classic AVR `PINx` register works the same way. 
* It is stronglty recommended that, on cores tha provide them, digitalWriteFast, pinModeFast, and similar be used to improve code readabiliy and prevent typos, as well as ensure that you only write compile time known pins and values. 

### SREG
One of the SFRs in the high I/O space, this is likely the most important register in AVR. After almost every mathematical or logical operation, it is updated to reflect the results. All conditional branches are based on the SREG (one bit is the Zero flag, indication a zero as the result of the last operation. This is used consantly - for example `while (x--)` decreements x until the Zero flag is set. Thhe high bit of the SREG is also the global interrupt bit. 

## General programming Terminology
`blocking` vs `non-blocking` function, call, or routine is one which, once called, will not return until some task has completed - when a function is described in this way, it implies that the function, internally, may be in a "busy-wait" state, or that it is waiting on a potentially very slow external event. . The most familiar example is the use of delay() for timekeeping vs millis(). delay() is an example of a blocking call - Like most blocking functions, it is easier and simpler to use than the non-blocking versions, but it's blocking nature make it frequently unsuitable. Non-blocking things (such as Serial prints from hardware serial ports) rely on interrupt driven stuff happening in the background 

## Arduino-specific Terminology
* `megaavr` is the name given by the Arduino developers to what was described above as "modern AVR" parts (see also above note on refering to types of parts). It is used in the "architectures" property of libraries to define which platforms are supported by that library, and the a `SOME SENTENCE MISSING (2020/08/07)`
* `arduino-land` is the Arduino community and the programming practices idioms and styles that are common or widespread there, as a community with a large proportion of hobbyists, many of whom have no programming experience outside of Arduino, plus high-school age students using it for class, relative to the number of professionals and higher-ed folks using it as a light-weight IDE, method of setting up toolchains and an expedient starting point for development (much of the magic of Arduino, IMHO, is that the same tools and IDE can be used effectively by someone who never wrote code in their life before the start of the semester, and an experienced programmer writing inline assembly, and have it work well for both of them. The inhabitants of Arduino-land are diverse and heterogeneous - they run the gamut from complete novice to deep experts, and the community includes many people who are both at once - yours truely has had dreams in AVR machine code, but don't ask me to work with C++ class inheritance) But this means that you should expect that bothe very pooor coding practices and very sophisticated code coding practices are widespread, ideoms and advise are spread without understanding, and *bad* advise persists far longer than it should. The users who will pick up code that you share may be very inexperienced. Even with my cores, which add support for non-standard parts to Arduino, I routinely receive questions from people who aappear to have no experience using common Arduino boards when they pick up exotic new (or exotic *old*) parts that they want to use. Many of the users who do have experience are retired, and apt to suggest obsolete parts or approaches to solving common oproblems (that, and the use of old vbooks long after their sell-by date has passed is a large part of why you see so much talk about ANCIENT parts here). 
