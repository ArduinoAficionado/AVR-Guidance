# Timers
Timers are used for generating PWM, timing events (using input capture) and to provide the millis() timing functionality. A timer has a clock source - usually the system clock, prescaled by some factor of two, and a "count" register which counts up or down (sometimes direction is configurable, sometimes not); the size of this count register (in bits) determines the "period" of the timer (how many clocks it can count before overflowing), and the resolution of PWM it can generate. Timers also have additional functionality on top of that; - most can do "waveform generation", otherwise known as PWM, all can generate interrupts upon overflow (and sometimes in other events), and some (usually 16-bit ones) can do "input capture" where upon a pre-selected pin changing state or event, the value of the timer will be copied to a "capture" register and an inrterrupt triggered - this allows precise timing of events (useful for timing events) without requiring the full attention of the processor (as is the case with something like pulseIn). 

Most timers are synchronous - that is, they are always clocked from the (optionally prescaled) system timer, and there is no delay between when changes to configuration registers are made, and when they take effect. Some timers however are not constrained in this way: they can run at a different freuqnecy provided by an external clock source, or may run at some multiple of the system clock, allowing higher frequency PWM.- depending on the specifics this can provide additional functionality, but it also makes them more difficult to work with because it introduces a "synchronization delay" whcen changing the values ocertain registers. On example of this is, in ATTinyCore, the Optiboot bootloader sets up a timer, sets it's count register so it will take about 1/8th of a second to overflow, clears the overflow flag (TOV1), and then waits in a while loop until TOV1 is set again. On the ATtiny861, however, this sdidn't work - about half of the delays were only a few clock cycles. Eventually it became evident what was happening here - the timer used is asyncronous, so the clearing of TOV1 flag sometimes had not completed by the time it reached the while look - so it would immediately exit that while loop! Solving this required simply waiting for the bit to be cleared before checking for being set again, but realizing that was what was happening took a long time. 

## Types of PWM
While for the most familar use of PWM, dimming an LED, all that matters is the frequency (And even then, we only care that it's fast enough that the human eye can't see the flicker), for more complicated applications, particularly motor control .
### Fast PWM 
The timer counts in one direction until it reaches the maximum, then wraps back to other end. Assuming it's counting up, the output pin is set at the start of the cycle and cleared when it matches the "compare value" (which sets the duty cycle). If downcounting, the reverse is true.
### Phase-correct PWM
The timer first counts in up, and then counts back down (in each direction, it works as described above. Hence, the frequency is half what it would be if the timer were using Fast PWM. Timers offering this option will generally apply updates to the compare and TOP values at the TOP of the cycle preventing a "glitch" when the compare value is changed in the middle of a cycle. This makes them better suited to motor control applcations. The fact that the frequwncy is half what it otherwise would be for the same resolution can be useful for getting the desired frequency without sacrificing resolution.

### Phase and freqnency correct PWM


## Classic AVR Timers

### 8-bit timer with two PWM channels (Timer0)
Almost every classic AVR has the same Timer0 - 8 bits, no frills timer with two PWM channels. This is almost invariably used for millis() on Arduino, as it is both the least interesting timer to take over for other uses, and is present everywhere, simplifying the implementation of millis across different devices. In that configuration they are used in fast PWM mode. They do not support input capture, amd support Fast PWM and Phase Correct PWM modes. They can be clocked from system clock prescaled by 1, 8, 64, 256, or 1024, or from an external clock on a specified pin - hwoever this external clock is sampled once per system clock, so the frequency should be less than half the system clock. Changing TOP is only possible by sacrificing one of the compare channels.

### 16-bit timer with PWM (Timer1, and sometimes others as well)
Most (but not all) classoc AVR parts have at least one of these timers. Sometimes known as "the good timer" as it is by far the most useful for typical applications. It supports full 16-bit PWM in fast, phase correct, and phase and frequency correct mode (though for Arduino purposes, it is set up in 8-bit mode, to work with the 8-bit value passed to analogWrite. These support input capture on a specific pin, and can often be configured to instead be controlled by the analog comparator (note that a reference voltage can be set as the other side of the analog comparator, this "trick" allows the analog comparator input pin to be used instead of the single ICR pin). Note that becasue the timer is not automatically reset when doing input capture, your code has to track the successive capture values, or else reset it to 0 every time a capture interrupt occurs; if you care about both HIGH and LOW times, you also need to switch the edge it's looking for in each interrupt (though, for many use cases, you do not) 

### 8-bit async timer with PWM

