The __AVR_ARCH__ define, provided by the compiler toolchain, has become apparent as a source of particularly relevant information on the so-called "modern AVR" parts, that is parts released since 2016 with the "core independent peripherals" (event system, timers identified by letter and number, not just number, `PERIPHERALn.REGISTER` instead of `PERIPHERAL1REGISTER` naming of peripherals, etc. They also run the AVRxt version of the instruction set (which has a few significant timing differences (in brief, SBI/CBI, all CALL variants, ST, and PUSH all lost a cycle = BUT - LDS, inexplicably, gained a cycle. And yes, this does mean you need to re-tune all your hand tuned assembly). But I digress; the topic of this page is the __AVR_ARCH__ define - for these parts, values of 102, 103, and 104 have been seen in the wild. The meaning of these is actually incredibly simple: It tells you whether the entire flash is memorymapped at any given time, and if not, how many sections it is divided across. 

* `__AVR_ARCH__ == 103` - All parts where all of the flash is mapped in the data space. This means Dx-series parts with 32k of flash, tinyAVR 0/1/2-series, and megaAVR 0-series.
* `__AVR_ARCH__ == 104` - Parts with 128Kb of flash, mapped flash is split into 4 sections (AVR128DA, AVR128DB).
* `__AVR_ARCH__ == 102` - Parts with 64Kb of flash, mapped flash is split into 2 sections (AVR64DA, AVR64DB).
