# Glossary of terms
This covers terms which are not already in ubiquitous use within the Arduino and AVR communities in the wider internet. It came out of a need for words or phrases to describe certain concepts which are routinely referenced. In some cases these terms were in use - although not common use - before. In other cases, descriptive words were chosen in the hopes of being self-explanitory (but which may not be). Confusing terminology used in the documentation for cores that I maintain should be covered here - Please report as an issue for this repo if you find words that need a definition in my documentation. 

**Status: Far from complete, but still useful**

## Terms for types of AVRs
Docs I write use two unofficial names to refer to the two broad classes of parts to which this guide applies. This is not the official terminology that Microchip uses. 
* `classic AVR` refers to any AVR part with the old syle peripherals - specifically, each port is controlled by registers named PORTx, PINx, DDRx (where x is the letter representing the port in question). The classic AVRs have very similar peripherals - they basically have a set of peripherals chosen from a list of standard peripherals (though there are a few parts with one or more unique peripherals - for example, the tiny x5 and x61 series both have a "high-speed timer" instead of the usual Timer1, though there are significant differences between the timers on those parts). See [classicperipheraltable.md](this table of Classic AVR peripherals and which parts have them) for a full list (this table has not been created as of 4/14/2020, but it will be)
* `modern AVR` refers to any AVR part with the new-style peripherals - this currently includes the tinyAVR 0-series and 1-series, the megaAVR 0-series, and the AVR-DA series (which appears to be what would have been the megaAVR 1-series, had they not changed the branding. This had previously been referred to as "megaavr" in many Arduino circles, amd that is what the IDE internally calls this architecture - however this terminology is unofficial, and presents confusion, since Microchip refers to all ATmega processors as "megaAVR". We try to avoid using `modern AVR` except where it is onerous to avoid.

The official terminology for these series of parts is as follows:
* 'tinyAVR` - All 'ATtiny' devices.
* `tinyAVR 0-series` and `tinyAVR 1-series` - The ATtiny devices featuring the new peripherals
* `megaAVR` - All 'ATmega' devices
* `megaAVR 0-series` - The ATmega4809, 4808, and smaller-flash versions of these parts, featuring the new peripherals.
* `AVR DA-series` - The newest 8-bit AVR devices, featuring the new peripherals plus additional enhanced features.
* `AVR Dx-series` - The DA-series, and upcoming DB-series, and any future parts named similarly. Marked as official as this is in the Microchip ATPACK name.

## General Terminology
Sorted by approximate frequncy of use

* `target` the device being programmed. Generally used when the programming is performed through another device, referred to as the `programmer` - particularly when the programmer is also programmable via the Arduino IDE (such as with Arduino as ISP, or jtag2updi) and probably has pins with the same or similar names as the target.
* `toolchain` refers to the package of compiler tools and libraries required to compile code for a given architecture. In the context of Arduino and AVR parts, this consists of avr-gcc, the device-specs which contain information on specific parts, the linker scripts which tell the linker where to locate the compiled code within the compiled binary, the precompiled .a and .o files for specific parts, and avr-libc, the collection of standard C/C++ libraries that provide basic functionality for the AVR parts and provide very basic wrappers around AVR peripherals. avr-gcc and avr-libc are available as separate packages, while the part specific libraries, including io*.h are supplied by the "atpacks"provided by Microchip. The Arduino compiler toolchain packages contain all three, and precompile a large number of device-specific .o files.
* `core` colloquially refers to the package of files that can be used to add support for new parts to the IDE; that is why almost every hardware package includes "core" in it's name. *Technically*, the `core` specifically refers to the implementation of the Arduino functions on that class of processors, rather than the rest of the package - the board, platform, programmer definitions, for example, though the two are usually tightly coupled. Depending on the specific hardware package (and the demands of the parts it supports), the core may or may not be shared with other hardware packages (for example, (almost?) all classic megaAVR parts can use the same core; similarly megaAVR 0-series and tinyAVR 0/1-series devices could the same core - though currently they do not, for a variety of reasons.
* `variant` As noted above, hardware packages will often support many parts which can share the same core. The differences betweem parts with different numbers of pins or port-to-pin mappings are often provided by a single file within the "variants" directory inside the hardware package, which typically contains only a single file: pins_arduino.c. This is the file that contains arrays and macros that map Arduino pin numbers to ports, analog pin numbers (`An` naming) to ADC channels, PWM pins to their timer and channel, and so on. Parts that differ only in the amount of RAM (and sometimes presence or absence of peripherals, for example, tinyAVR 1-series vs 0-series) can be supported with the same variant.
* `UART` - Also called a `serial port` - this is what is used by Serial. The name stands for Universal Asynchronous Receiver-Transmitter. See also `USART` below for usage notes. 
* `USART` - As above, but has an additional feature that an XCK pin can be used as a clock, instead of using a pre-arranged baud rate. It is common for `UART` to be used to refer to either type: a USART can act as a UART, but a UART cannot do synchronous serial, only async. Stands for Universal Synchronous/Asynchronous Receiver-Transmitter. AVR parts generally (all?) have a USART, not just a UART - however, use of the XCK pin is unheardof in Arduino applications, and quite rare in general - it is a "low cost" feature for the manufacturer to implement - likely basically free if there is support for reconfiguring a USART to act as an SPI port, which is ubiquitous on AVR parts.
* `mxxx` and `txxx` are shorthand for megaAVR and tinyAVR devices, eg, m328p refers to the ATmega328p, t3216 refers to the ATtiny3216. This shorthand is derived from the abbreviations used by AVRdude to refer to these parts. `tnxxx` is also sometimes used for the ATtiny parts, though less commonly; this is the abbreviation used by the compiler toolchain, though rarely seen outside of it.
## Arduino-specific Terminology
* `megaavr` is the name given by the Arduino developers to what was described above as "modern AVR" parts (see also above note on refering to types of parts). It is used in the "architectures" property of libraries to define which platforms are supported by that library, and the a
* `arduino-land` is the Arduino community and the programming practices idioms and styles that are common or widespread there, as a community with a mostly hobbyists, including a large number of inexperienced users, many of whom have no programming experience outside of Arduino. This is not meant to be derogatory - the low barrier to entry is a wonderful thing, and it's great that so many people use it - but it does mean Arduino code is usually going to be less "sophisticated", and poor coding practices should be assumed to be common. When I use it, it is meant as a reminder that code written in the Arduino context is often - but not always - less advanced than, say, a typical user of Atmel Studio. Advanced features of peripherals will rarely, if ever, be used in arduino-land, practices like checking reset cause and resetting the reset flags are little-known, even when they would make sense, and Arduino abstractions are used more often than not. Hence, advanced code that will be used by arduino-land (such as libraries that do the "hard part" of some task, cores, and bootloaders) should not require advanced practices to use, providing this is possible without compromising the functionality of the code. For extra credit, if you know people will be using a sketch as a starting point or example, don't make the coding style unnecessarily obtuse, and pay particular attention to commenting well.  Note that not **all** Arduino code is like that - there are Arduino sketches out there that use all manner of complex tricks as well as code that sticks to the simple Arduino API, and everything in between. One big challenge as a developer of code others will use is in keeping both the novice and expert users happy (or recognizing that your code is only of interest to either novice or advanced users - which again, isn't a bad thing. For example, the expert isn't going to bother with a library that puts a wrapper around direct port writes, while the novice isn't going to be modifying your bootloader).
